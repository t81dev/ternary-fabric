#!/usr/bin/env python3
from __future__ import annotations

"""Compare compiler and runtime fusion telemetry (produced by the regression suite).

Compiler telemetry dictionaries are generated by running
`tools/torch_to_tfmbs.py` + `tests/mlir/run_tfmbs_to_linalg.py` (or via
`ninja -C build check-tfmbs`). That regression suite emits
`fusion_order`/`fusion_sparsity` hints inside the `tests/mlir/*.mlir`
fixtures, which the dashboard compares against `AdaptiveRuntimeAgent` logs.
"""

import argparse
import ast
import json
import re
from pathlib import Path
from typing import Any, Dict, List

from importlib import util

def load_adaptive_runtime_agent_class() -> type["AdaptiveRuntimeAgent"]:
    agent_path = Path(__file__).resolve().parent.parent / "src" / "pytfmbs" / "adaptive_agent.py"
    spec = util.spec_from_file_location("tfmbs_adaptive_agent", agent_path)
    module = util.module_from_spec(spec)
    assert spec.loader is not None
    spec.loader.exec_module(module)
    return module.AdaptiveRuntimeAgent


def parse_mlir_telemetry(mlir_path: Path) -> List[Dict[str, Any]]:
    """Extract telemetry dictionaries from `tfmbs.gemv` ops inside MLIR."""
    telemetry_entries: List[Dict[str, Any]] = []
    for line in mlir_path.read_text().splitlines():
        if "telemetry" not in line:
            continue
        start = line.find("{", line.index("telemetry"))
        if start == -1:
            continue
        depth = 0
        end = start
        for idx in range(start, len(line)):
            char = line[idx]
            if char == "{":
                depth += 1
            elif char == "}":
                depth -= 1
            if depth == 0:
                end = idx + 1
                break
        segment = line[start:end]
        sanitized = re.sub(r"([a-zA-Z_]\w*)\s*=", r'"\1":', segment)
        telemetry_entries.append(ast.literal_eval(sanitized))
    return telemetry_entries


def compare_entries(compile_hints: List[Dict[str, Any]], runtime_entries: List[Dict[str, Any]]) -> None:
    print(f"Compiler entries: {len(compile_hints)}, Runtime entries: {len(runtime_entries)}")
    runtime_order = runtime_entries[0]["fusion_order"] if runtime_entries else []
    compile_order = compile_hints[0]["fusion_order"] if compile_hints else []
    if compile_order == runtime_order:
        print("✅ Fusion order matches between compile/runtime (first entry).")
    else:
        print("⚠️  Fusion order mismatch (first entry)")
        print("    compile:", compile_order)
        print("    runtime:", runtime_order)
    compile_sparsity = compile_hints[0].get("fusion_sparsity", None)
    runtime_sparsity = runtime_entries[0].get("fusion_sparsity", None)
    if compile_sparsity is not None and runtime_sparsity is not None:
        delta = abs(compile_sparsity - runtime_sparsity)
        print(f"Fusion sparsity (compile/runtime): {compile_sparsity:.4f}/{runtime_sparsity:.4f} (Δ={delta:.4f})")
    if len(runtime_entries) > 1:
        print("Runtime telemetry history (tail 3):")
        for entry in runtime_entries[-3:]:
            print(" ", entry)


def main() -> int:
    parser = argparse.ArgumentParser(description="Adaptive Runtime Agent fusion dashboard.")
    parser.add_argument("--mlir", type=Path, default=Path("tests/mlir/torch_tfmbs.mlir"),
                        help="MLIR file with compiler telemetry.")
    parser.add_argument("--runtime", type=Path, default=Path("logs/adaptive_history.json"),
                        help="Runtime telemetry history produced by AdaptiveRuntimeAgent.")
    parser.add_argument("--hw-runtime", type=Path,
                        help="Physical hardware telemetry history log for comparison.")
    parser.add_argument("--no-clash", action="store_true",
                        help="Skip comparison when runtime data is missing.")
    args = parser.parse_args()

    if not args.mlir.is_file():
        raise FileNotFoundError(f"Compile MLIR not found: {args.mlir}")
    compile_hints = parse_mlir_telemetry(args.mlir)
    runtime_entries: List[Dict[str, Any]] = []
    if args.runtime.is_file():
        agent_cls = load_adaptive_runtime_agent_class()
        runtime_entries = agent_cls.load_history(args.runtime)
    elif not args.no_clash:
        raise FileNotFoundError(f"Runtime telemetry log missing: {args.runtime}")

    print(f"Compile fusion order(s): {[entry.get('fusion_order') for entry in compile_hints]}")
    if runtime_entries:
        print("\n--- Simulation Runtime Analysis ---")
        compare_entries(compile_hints, runtime_entries)

    if args.hw_runtime and args.hw_runtime.is_file():
        agent_cls = load_adaptive_runtime_agent_class()
        hw_entries = agent_cls.load_history(args.hw_runtime)
        print("\n--- Physical Hardware Analysis ---")
        compare_entries(compile_hints, hw_entries)
    elif args.hw_runtime:
        print(f"HW runtime log not found: {args.hw_runtime}")

    if not runtime_entries and not args.hw_runtime:
        print("Runtime telemetry log not provided; run AdaptiveRuntimeAgent.save_history() to generate it.")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
